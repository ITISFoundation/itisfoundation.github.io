{
  "version": 3,
  "sources": [
    "../transpiled/qx/event/message/Bus.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "build-output/testtapper/part-boot-bundle-21.js.map",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Christian Boulanger\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger\n\n************************************************************************ */\n\n/**\n * A simple message bus singleton.\n * The message bus registers subscriptions and notifies subscribers when\n * a matching message is dispatched\n */\nqx.Class.define(\"qx.event.message.Bus\",\n{\n  type : \"singleton\",\n\n  extend : qx.core.Object,\n\n  statics :\n  {\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.getInstance().getSubscriptions();\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().subscribe(message, subscriber, context);\n\n    },\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      return this.getInstance().checkSubscription(message, subscriber, context);\n    },\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().unsubscribe(message, subscriber, context);\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      return this.getInstance().dispatch.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      return this.getInstance().dispatchByName.apply(this.getInstance(), arguments);\n    }\n  },\n\n  /**\n   * constructor\n   */\n  construct : function()\n  {\n    /*\n     * message subscriptions database\n     */\n    this.__subscriptions = {};\n  },\n\n  members :\n  {\n    __subscriptions : null,\n\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.__subscriptions;\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      if (!message || typeof subscriber != \"function\")\n      {\n        this.error(\"Invalid parameters! \"+ [message, subscriber, context]);\n\n        return false;\n      }\n\n      var sub = this.getSubscriptions();\n\n      if (this.checkSubscription(message))\n      {\n        if (this.checkSubscription(message, subscriber, context))\n        {\n          this.warn(\"Object method already subscribed to \" + message);\n          return false;\n        }\n\n        // add a subscription\n        sub[message].push(\n        {\n          subscriber : subscriber,\n          context    : context || null\n        });\n\n        return true;\n      }\n      else\n      {\n        // create a subscription\n        sub[message] = [ {\n          subscriber : subscriber,\n          context    : context || null\n        } ];\n\n        return true;\n      }\n    },\n\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      var sub = this.getSubscriptions();\n\n      if (!sub[message] || sub[message].length === 0) {\n        return false;\n      }\n\n      if (subscriber)\n      {\n        for (var i=0; i<sub[message].length; i++)\n        {\n          if (sub[message][i].subscriber === subscriber && sub[message][i].context === (context || null)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    },\n\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n       var sub = this.getSubscriptions();\n       var subscrList = sub[message];\n       if (subscrList) {\n         if (!subscriber) {\n           sub[message] = null;\n           delete sub[message];\n           return true;\n         } else {\n           if (! context) {\n             context = null;\n           }\n           var i = subscrList.length;\n           var subscription;\n           do {\n             subscription = subscrList[--i];\n             if (subscription.subscriber === subscriber && subscription.context === context) {\n               subscrList.splice(i, 1);\n               if (subscrList.length === 0) {\n                 sub[message] = null;\n                 delete sub[message];\n               }\n               return true;\n             }\n           } while (i);\n         }\n       }\n       return false;\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      var sub = this.getSubscriptions();\n      var msgName = msg.getName();\n      var dispatched = false;\n\n      for (var key in sub)\n      {\n        var pos = key.indexOf(\"*\");\n\n        if (pos > -1)\n        {\n          // use of wildcard\n          if (pos === 0 || key.substr(0, pos) === msgName.substr(0, pos))\n          {\n            this.__callSubscribers(sub[key], msg);\n            dispatched = true;\n          }\n        }\n        else\n        {\n          // exact match\n          if (key === msgName)\n          {\n            this.__callSubscribers(sub[msgName], msg);\n            dispatched = true;\n          }\n        }\n      }\n\n      return dispatched;\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      var message = new qx.event.message.Message(name, data);\n\n      // Dispatch the message\n      var ret = this.dispatch(message);\n\n      // We instantiated this message, so it's our responsibility to dispose it.\n      message.dispose();\n      message = null;\n\n      // Let 'em know whether this message was dispatched to any subscribers.\n      return ret;\n    },\n\n\n    /**\n     * Call subscribers with passed message.\n     *\n     * Each currently-subscribed subscriber function will be called in\n     * turn. Any requests to unsubscribe a subscriber from the list, while\n     * processing the currently-subscribed subscriber functions, will take\n     * effect after all currently-subscribed subscriber functions have been\n     * processed.\n     *\n     * @param subscribers {Array} subscribers to call\n     * @param msg {qx.event.message.Message} message for subscribers\n     */\n    __callSubscribers : function(subscribers, msg)\n    {\n      // (Shallow) clone the subscribers array in case one of them alters the\n      // list, e.g., by unsubscribing\n      subscribers = subscribers.slice();\n\n      for (var i=0; i<subscribers.length; i++)\n      {\n        var subscriber = subscribers[i].subscriber;\n        var context = subscribers[i].context;\n\n        // call message monitor subscriber\n        if (context && context.isDisposed)\n        {\n          if (context.isDisposed())\n          {\n            subscribers.splice(i, 1);\n            i--;\n          }\n          else\n          {\n            subscriber.call(context, msg);\n          }\n        }\n        else\n        {\n          subscriber.call(context, msg);\n        }\n      }\n    }\n  }\n});\n"
  ]
}