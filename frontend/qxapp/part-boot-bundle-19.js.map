{
  "version": 3,
  "sources": [
    "../transpiled/qx/ui/form/validation/Manager.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "build-output/qxapp/part-boot-bundle-19.js.map",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n/**\n * This validation manager is responsible for validation of forms.\n *\n * @ignore(qx.ui.tooltip)\n * @ignore(qx.ui.tooltip.Manager.*)\n */\nqx.Class.define(\"qx.ui.form.validation.Manager\",\n{\n  extend : qx.core.Object,\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    // storage for all form items\n    this.__formItems = [];\n    // storage for all results of async validation calls\n    this.__asyncResults = {};\n    // set the default required field message\n    this.setRequiredFieldMessage(qx.locale.Manager.tr(\"This field is required\"));\n  },\n\n\n  events :\n  {\n    /**\n     * Change event for the valid state.\n     */\n    \"changeValid\" : \"qx.event.type.Data\",\n\n    /**\n     * Signals that the validation is done. This is not needed on synchronous\n     * validation (validation is done right after the call) but very important\n     * in the case an asynchronous validator will be used.\n     */\n    \"complete\" : \"qx.event.type.Event\"\n  },\n\n\n  properties :\n  {\n    /**\n     * The validator of the form itself. You can set a function (for\n     * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.\n     * In both cases, the function can have all added form items as first\n     * argument and the manager as a second argument. The manager should be used\n     * to set the {@link #invalidMessage}.\n     *\n     * Keep in mind that the validator is optional if you don't need the\n     * validation in the context of the whole form.\n     * @type {Function | AsyncValidator}\n     */\n    validator :\n    {\n      check : \"value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)\",\n      init : null,\n      nullable : true\n    },\n\n    /**\n     * The invalid message should store the message why the form validation\n     * failed. It will be added to the array returned by\n     * {@link #getInvalidMessages}.\n     */\n    invalidMessage :\n    {\n      check : \"String\",\n      init: \"\"\n    },\n\n\n    /**\n     * This message will be shown if a required field is empty and no individual\n     * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.\n     */\n    requiredFieldMessage :\n    {\n      check : \"String\",\n      init : \"\"\n    },\n\n\n    /**\n     * The context for the form validation.\n     */\n    context :\n    {\n      nullable : true\n    }\n  },\n\n\n  members :\n  {\n    __formItems : null,\n    __valid : null,\n    __asyncResults : null,\n    __syncValid : null,\n\n\n    /**\n     * Add a form item to the validation manager.\n     *\n     * The form item has to implement at least two interfaces:\n     * <ol>\n     *   <li>The {@link qx.ui.form.IForm} Interface</li>\n     *   <li>One of the following interfaces:\n     *     <ul>\n     *       <li>{@link qx.ui.form.IBooleanForm}</li>\n     *       <li>{@link qx.ui.form.IColorForm}</li>\n     *       <li>{@link qx.ui.form.IDateForm}</li>\n     *       <li>{@link qx.ui.form.INumberForm}</li>\n     *       <li>{@link qx.ui.form.IStringForm}</li>\n     *     </ul>\n     *   </li>\n     * </ol>\n     * The validator can be a synchronous or asynchronous validator. In\n     * both cases the validator can either returns a boolean or fire an\n     * {@link qx.core.ValidationError}. For synchronous validation, a plain\n     * JavaScript function should be used. For all asynchronous validations,\n     * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the\n     * plain function.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to add.\n     * @param validator {Function | qx.ui.form.validation.AsyncValidator}\n     *   The validator.\n     * @param context {var?null} The context of the validator.\n     */\n    add: function(formItem, validator, context) {\n      // check for the form API\n      if (!this.__supportsInvalid(formItem)) {\n        throw new Error(\"Added widget not supported.\");\n      }\n      // check for the data type\n      if (this.__supportsSingleSelection(formItem) && !formItem.getValue) {\n        // check for a validator\n        if (validator != null) {\n          throw new Error(\"Widgets supporting selection can only be validated \" +\n          \"in the form validator\");\n        }\n      }\n      var dataEntry =\n      {\n        item : formItem,\n        validator : validator,\n        valid : null,\n        context : context\n      };\n      this.__formItems.push(dataEntry);\n    },\n\n\n    /**\n     * Remove a form item from the validation manager.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to remove.\n     * @return {qx.ui.core.Widget?null} The removed form item or\n     *  <code>null</code> if the item could not be found.\n     */\n    remove : function(formItem)\n    {\n      var items = this.__formItems;\n\n      for (var i = 0, len = items.length; i < len; i++)\n      {\n        if (formItem === items[i].item)\n        {\n          items.splice(i, 1);\n          return formItem;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Returns registered form items from the validation manager.\n     *\n     * @return {Array} The form items which will be validated.\n     */\n    getItems : function()\n    {\n      var items = [];\n      for (var i=0; i < this.__formItems.length; i++) {\n        items.push(this.__formItems[i].item);\n      };\n      return items;\n    },\n\n\n    /**\n     * Invokes the validation. If only synchronous validators are set, the\n     * result of the whole validation is available at the end of the method\n     * and can be returned. If an asynchronous validator is set, the result\n     * is still unknown at the end of this method so nothing will be returned.\n     * In both cases, a {@link #complete} event will be fired if the validation\n     * has ended. The result of the validation can then be accessed with the\n     * {@link #getValid} method.\n     *\n     * @return {Boolean|undefined} The validation result, if available.\n     */\n    validate : function() {\n      var valid = true;\n      this.__syncValid = true; // collaboration of all synchronous validations\n      var items = [];\n\n      // check all validators for the added form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        var validator = this.__formItems[i].validator;\n\n        // store the items in case of form validation\n        items.push(formItem);\n\n        // ignore all form items without a validator\n        if (validator == null) {\n          // check for the required property\n          var validatorResult = this._validateRequired(formItem);\n          valid = valid && validatorResult;\n          this.__syncValid = validatorResult && this.__syncValid;\n          continue;\n        }\n\n        var validatorResult = this._validateItem(\n          this.__formItems[i], formItem.getValue()\n        );\n        // keep that order to ensure that null is returned on async cases\n        valid = validatorResult && valid;\n        if (validatorResult != null) {\n          this.__syncValid = validatorResult && this.__syncValid;\n        }\n      }\n\n      // check the form validator (be sure to invoke it even if the form\n      // items are already false, so keep the order!)\n      var formValid = this.__validateForm(items);\n      if (qx.lang.Type.isBoolean(formValid)) {\n        this.__syncValid = formValid && this.__syncValid;\n      }\n      valid = formValid && valid;\n\n      this._setValid(valid);\n\n      if (qx.lang.Object.isEmpty(this.__asyncResults)) {\n        this.fireEvent(\"complete\");\n      }\n      return valid;\n    },\n\n\n    /**\n     * Checks if the form item is required. If so, the value is checked\n     * and the result will be returned. If the form item is not required, true\n     * will be returned.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to check.\n     * @return {var} Validation result\n     */\n    _validateRequired : function(formItem) {\n      if (formItem.getRequired()) {\n        var validatorResult;\n        // if its a widget supporting the selection\n        if (this.__supportsSingleSelection(formItem)) {\n          validatorResult = !!formItem.getSelection()[0];\n\n        } else if (this.__supportsDataBindingSelection(formItem)) {\n          validatorResult = (formItem.getSelection().getLength() > 0);\n\n        } else {\n          var value = formItem.getValue();\n          validatorResult = !!value || value === 0;\n        }\n        formItem.setValid(validatorResult);\n        var individualMessage = formItem.getRequiredInvalidMessage();\n        var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();\n        formItem.setInvalidMessage(message);\n        return validatorResult;\n      }\n      return true;\n    },\n\n\n    /**\n     * Validates a form item. This method handles the differences of\n     * synchronous and asynchronous validation and returns the result of the\n     * validation if possible (synchronous cases). If the validation is\n     * asynchronous, null will be returned.\n     *\n     * @param dataEntry {Object} The map stored in {@link #add}\n     * @param value {var} The currently set value\n     * @return {Boolean|null} Validation result or <code>null</code> for async\n     * validation\n     */\n    _validateItem : function(dataEntry, value) {\n      var formItem = dataEntry.item;\n      var context = dataEntry.context;\n      var validator = dataEntry.validator;\n\n      // check for asynchronous validation\n      if (this.__isAsyncValidator(validator)) {\n        // used to check if all async validations are done\n        this.__asyncResults[formItem.toHashCode()] = null;\n        validator.validate(formItem, formItem.getValue(), this, context);\n        return null;\n      }\n\n      var validatorResult = null;\n\n      try {\n        var validatorResult = validator.call(context || this, value, formItem);\n        if (validatorResult === undefined) {\n          validatorResult = true;\n        }\n\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          validatorResult = false;\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          formItem.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n\n      formItem.setValid(validatorResult);\n      dataEntry.valid = validatorResult;\n\n      return validatorResult;\n    },\n\n\n    /**\n     * Validates the form. It checks for asynchronous validation and handles\n     * the differences to synchronous validation. If no form validator is given,\n     * true will be returned. If a synchronous validator is given, the\n     * validation result will be returned. In asynchronous cases, null will be\n     * returned cause the result is not available.\n     *\n     * @param items {qx.ui.core.Widget[]} An array of all form items.\n     * @return {Boolean|null} description\n     */\n    __validateForm: function(items) {\n      var formValidator = this.getValidator();\n      var context = this.getContext() || this;\n\n      if (formValidator == null) {\n        return true;\n      }\n\n      // reset the invalidMessage\n      this.setInvalidMessage(\"\");\n\n      if (this.__isAsyncValidator(formValidator)) {\n        this.__asyncResults[this.toHashCode()] = null;\n        formValidator.validateForm(items, this, context);\n        return null;\n      }\n\n      try {\n        var formValid = formValidator.call(context, items, this);\n        if (formValid === undefined) {\n          formValid = true;\n        }\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          formValid = false;\n\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          this.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n      return formValid;\n    },\n\n\n    /**\n     * Helper function which checks, if the given validator is synchronous\n     * or asynchronous.\n     *\n     * @param validator {Function|qx.ui.form.validation.AsyncValidator}\n     *   The validator to check.\n     * @return {Boolean} True, if the given validator is asynchronous.\n     */\n    __isAsyncValidator : function(validator) {\n      var async = false;\n      if (!qx.lang.Type.isFunction(validator)) {\n        async = qx.Class.isSubClassOf(\n          validator.constructor, qx.ui.form.validation.AsyncValidator\n        );\n      }\n      return async;\n    },\n\n\n    /**\n     * Returns true, if the given item implements the {@link qx.ui.form.IForm}\n     * interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsInvalid : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.ui.core.ISingleSelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsSingleSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.data.controller.ISelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsDataBindingSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);\n    },\n\n\n    /**\n     * Sets the valid state of the manager. It generates the event if\n     * necessary and stores the new value.\n     *\n     * @param value {Boolean|null} The new valid state of the manager.\n     */\n    _setValid: function(value) {\n      this._showToolTip(value);\n      var oldValue = this.__valid;\n      this.__valid = value;\n      // check for the change event\n      if (oldValue != value) {\n        this.fireDataEvent(\"changeValid\", value, oldValue);\n      }\n    },\n\n\n    /**\n     * Responsible for showing a tooltip in case the validation is done for\n     * widgets based on qx.ui.core.Widget.\n     * @param valid {Boolean} <code>false</code>, if the tooltip should be shown\n     */\n    _showToolTip : function(valid) {\n      // ignore if we don't have a tooltip manager e.g. mobile apps\n      if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {\n        return;\n      }\n      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();\n\n      if (!valid) {\n        var firstInvalid;\n        for (var i = 0; i < this.__formItems.length; i++) {\n          var item = this.__formItems[i].item;\n          if (!item.isValid()) {\n            firstInvalid = item;\n            // only for desktop widgets\n            if (!(item.getContentLocation)) {\n              return;\n            }\n            // only consider items on the screen\n            if (item.isSeeable() === false) {\n              continue;\n            }\n\n            tooltip.setLabel(item.getInvalidMessage());\n\n            if (tooltip.getPlaceMethod() == \"mouse\") {\n              var location = item.getContentLocation();\n              var top = location.top - tooltip.getOffsetTop();\n              tooltip.placeToPoint({left: location.right, top: top});\n            } else {\n              tooltip.placeToWidget(item);\n            }\n\n            tooltip.show();\n            return;\n          }\n        }\n      } else {\n        tooltip.exclude();\n      }\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    getValid: function() {\n      return this.__valid;\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    isValid: function() {\n      return this.getValid();\n    },\n\n\n    /**\n     * Returns an array of all invalid messages of the invalid form items and\n     * the form manager itself.\n     *\n     * @return {String[]} All invalid messages.\n     */\n    getInvalidMessages: function() {\n      var messages = [];\n      // combine the messages of all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          messages.push(formItem.getInvalidMessage());\n        }\n      }\n      // add the forms fail message\n      if (this.getInvalidMessage() != \"\") {\n        messages.push(this.getInvalidMessage());\n      }\n\n      return messages;\n    },\n\n\n    /**\n     * Selects invalid form items\n     *\n     * @return {Array} invalid form items\n     */\n    getInvalidFormItems : function() {\n      var res = [];\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          res.push(formItem);\n        }\n      }\n\n      return res;\n    },\n\n\n    /**\n     * Resets the validator.\n     */\n    reset: function() {\n      // reset all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var dataEntry = this.__formItems[i];\n        // set the field to valid\n        dataEntry.item.setValid(true);\n      }\n      // set the manager to its initial valid value\n      this.__valid = null;\n      this._showToolTip(true);\n    },\n\n\n    /**\n     * Internal helper method to set the given item to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to set the valid state.\n     * @param valid {Boolean} The valid state for the form item.\n     *\n     * @internal\n     */\n    setItemValid: function(formItem, valid) {\n      // store the result\n      this.__asyncResults[formItem.toHashCode()] = valid;\n      formItem.setValid(valid);\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Internal helper method to set the form manager to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param valid {Boolean} The valid state for the form manager.\n     *\n     * @internal\n     */\n    setFormValid : function(valid) {\n      this.__asyncResults[this.toHashCode()] = valid;\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Checks if all asynchronous validators have validated so the result\n     * is final and the {@link #complete} event can be fired. If that's not\n     * the case, nothing will happen in the method.\n     */\n    __checkValidationComplete : function() {\n      var valid = this.__syncValid;\n\n      // check if all async validators are done\n      for (var hash in this.__asyncResults) {\n        var currentResult = this.__asyncResults[hash];\n        valid = currentResult && valid;\n        // the validation is not done so just do nothing\n        if (currentResult == null) {\n          return;\n        }\n      }\n      // set the actual valid state of the manager\n      this._setValid(valid);\n      // reset the results\n      this.__asyncResults = {};\n      // fire the complete event (no entry in the results with null)\n      this.fireEvent(\"complete\");\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n  destruct : function()\n  {\n    this._showToolTip(true);\n    this.__formItems = null;\n  }\n});\n"
  ]
}